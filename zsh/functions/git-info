#autoload

emulate -L zsh

typeset -gA gitstate
local gitdir grevparse gstatus tmp

gitdir="$(git rev-parse --git-dir 2>/dev/null)" || return 1
grevparse=( "${(@f)$(git rev-parse \
    --is-inside-work-tree \
    --is-inside-git-dir \
    --is-bare-repository \
    --show-prefix \
    --show-toplevel)}" )
gstatus=( "${(@f)$(git status --porcelain --branch 2>/dev/null)}" )

gitstate[gitdir]=${gitdir:A}
gitstate[inworktree]=$((${grevparse[1]/true/1}))
gitstate[ingitdir]=$((${grevparse[2]/true/1}))
gitstate[isbare]=$((${grevparse[3]/true/1}))
gitstate[prefix]=${grevparse[4]}
gitstate[root]=${grevparse[5]}
gitstate[name]=${grevparse[5]:t}

if [[ -f ${gitdir}/MERGE_HEAD ]] {
    gitstate[state]="merge"
    gitstate[target_sha1]="$(git rev-parse MERGE_HEAD)"
} elif [[ -d ${gitdir}/rebase-apply ]] {
    if [[ -f ${gitdir}/rebase-apply/applying ]] {
        gitstate[state]="am"
    } else {
        gitstate[state]="rebase"
        gitstate[head_sha1]="$(<${gitdir}/rebase-apply/orig-head)"
        gitstate[head_fullname]="$(<${gitdir}/rebase-apply/head-name)"
        if [[ ${gitstate[head_fullname]} == "detached HEAD" ]] {
            gitstate[head_detached]=1
        }
        gitstate[target_sha1]="$(<${gitdir}/rebase-apply/onto)"
    }
    gitstate[step]="$(<${gitdir}/rebase-apply/next)"
    gitstate[total]="$(<${gitdir}/rebase-apply/last)"
} elif [[ -d ${gitdir}/rebase-merge ]] {
    if [[ -f ${gitdir}/rebase-merge/interactive ]] {
        gitstate[state]="rebase-i"
    } else {
        gitstate[state]="rebase-m"
    }
    gitstate[head_sha1]="$(<${gitdir}/rebase-merge/orig-head)"
    gitstate[head_fullname]="$(<${gitdir}/rebase-merge/head-name)"
    if [[ ${gitstate[head_fullname]} == "detached HEAD" ]] {
        gitstate[head_detached]=1
    }
    gitstate[target_sha1]="$(<${gitdir}/rebase-merge/onto)"
    gitstate[step]="$(<${gitdir}/rebase-merge/msgnum)"
    gitstate[total]="$(<${gitdir}/rebase-merge/end)"
} elif [[ -f ${gitdir}/CHERRY_PICK_HEAD ]] {
    gitstate[state]="cherry-pick"
    gitstate[target_sha1]="$(git rev-parse CHERRY_PICK_HEAD)"
    if [[ -f ${gitdir}/sequencer/todo ]] {
        tmp="$(git rev-list sequencer/head..HEAD | wc -l)"
        gitstate[step]=$(( tmp + 1 ))
        gitstate[total]=$(( tmp + "$(wc -l ${gitdir}/sequencer/todo)" ))
    } else {
        gitstate[step]=1
        gitstate[total]=1
    }
} elif [[ -f ${gitdir}/REVERT_HEAD ]] {
    gitstate[state]="revert"
    gitstate[target_sha1]="$(git rev-parse REVERT_HEAD)"
    if [[ -f ${gitdir}/sequencer/todo ]] {
        tmp="$(git rev-list sequencer/head..HEAD | wc -l)"
        gitstate[step]=$(( tmp + 1 ))
        gitstate[total]=$(( tmp + "$(wc -l ${gitdir}/sequencer/todo)" ))
    } else {
        gitstate[step]=1
        gitstate[total]=1
    }
} elif [[ -f ${gitdir}/BISECT_LOG ]] {
    gitstate[state]="bisect"
    tmp="$(git rev-list --bisect --bisect-vars 2>/dev/null)"
    if [[ -n "${tmp}" ]] {
        gitstate[step]="$(grep -cv '^#' ${gitdir}/BISECT_LOG)"
        gitstate[total]=$(( gitstate[step] + ${tmp[(fr)bisect_steps=*]#*=} ))
    }
} else {
    gitstate[state]=""
}

if (( ! ${+gitstate[head_sha1]} )) {
    if tmp="$(git symbolic-ref -q HEAD)"; then
        gitstate[head_fullname]=${tmp}
        if ! git show-ref --quiet --verify -- ${tmp}; then
            gitstate[head_unborn]=1
        fi
    else
        gitstate[head_detached]=1
    fi
    if (( ! ${+gitstate[head_unborn]} )) {
        gitstate[head_sha1]="$(git rev-parse HEAD)"
    }
}

if (( ! ${gitstate[head_unborn]:=0} )) {
    gitstate[head_abbrev]="$(git rev-parse --short ${gitstate[head_sha1]})"
}

if (( ! ${gitstate[head_detached]:=0} )) {
    if (( ${gitstate[head_unborn]} )) {
        gitstate[head_name]=${gitstate[head_fullname]#refs/heads/}
    } else {
        gitstate[head_name]="$(git rev-parse --abbrev-ref=strict ${gitstate[head_fullname]})"
    }
    if [[ ${gstatus[1]} =~ '\[ahead ([0-9]+)]$' ]] {
        gitstate[ahead]=${match[1]}
        gitstate[behind]=0
    } elif [[ ${gstatus[1]} =~ '\[behind ([0-9]+)]$' ]] {
        gitstate[ahead]=0
        gitstate[behind]=${match[1]}
    } elif [[ ${gstatus[1]} =~ '\[ahead ([0-9]+), behind ([0-9]+)]$' ]] {
        gitstate[ahead]=${match[1]}
        gitstate[behind]=${match[2]}
    } else {
        gitstate[ahead]=0
        gitstate[behind]=0
    }
} else {
    tmp="$(git for-each-ref --points-at=${gitstate[head_sha1]} --count=1 --format='%(refname)')"
    if [[ -n ${tmp} ]] {
        gitstate[head_fullname]=${tmp}
        gitstate[head_name]="$(git rev-parse --abbrev-ref=strict ${tmp})"
    } else {
        gitstate[head_fullname]=${gitstate[head_sha1]}
        gitstate[head_name]=${gitstate[head_abbrev]}
    }
    gitstate[ahead]=0
    gitstate[behind]=0
}

if (( ${+gitstate[target_sha1]} )) {
    gitstate[target_abbrev]="$(git rev-parse --short ${gitstate[target_sha1]})"
    tmp="$(git for-each-ref --points-at=${gitstate[target_sha1]} --count=1 --format='%(refname)')"
    if [[ -n ${tmp} ]] {
        gitstate[target_fullname]=${tmp}
        gitstate[target_name]="$(git rev-parse --abbrev-ref=strict ${tmp})"
    } else {
        gitstate[target_fullname]=${gitstate[target_sha1]}
        gitstate[target_name]=${gitstate[target_abbrev]}
    }
}

gitstate[untracked]=${(M)#gstatus:#\?\? *}
gitstate[wt_modified]=${(M)#gstatus:#([ MARC]M| A) *}
gitstate[wt_deleted]=${(M)#gstatus:#[ MARC]D *}
gitstate[unstaged]=${(M)#gstatus:#([ MARC][MD]| A) *}
gitstate[modified]=${(M)#gstatus:#M[ MD] *}
gitstate[added]=${(M)#gstatus:#A[ MD] *}
gitstate[deleted]=${(M)#gstatus:#D[ M] *}
gitstate[renamed]=${(M)#gstatus:#R[ MD] *}
gitstate[copied]=${(M)#gstatus:#C[ MD] *}
gitstate[staged]=${(M)#gstatus:#([MARC][ MD]|D[ M]) *}
gitstate[unmerged]=${(M)#gstatus:#(U[ADU]|A[AU]|D[DU]) *}
gitstate[stash]="$(git stash list --oneline 2>/dev/null | wc -l)"

return 0
