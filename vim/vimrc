" vim: set foldmethod=marker:

" prelude {{{1
let g:vimfiles = expand('<sfile>:p:h')
let g:isdev = isdirectory(expand('~/src'))
let g:uid = executable('id') ? str2nr(system('id -u')) : -1

" pyenv {{{2
if has('vim_starting') && executable('pipenv')
  let g:pyenv = g:vimfiles . '/.pyenv'

  if !isdirectory(g:pyenv . '/.venv')
    if g:isdev
      let s:cmd = ['pipenv', '--site-packages', 'install', '--dev']
    else
      let s:cmd = ['pipenv', 'install']
    endif
    let s:job = job_start(s:cmd, {
          \   'cwd': g:pyenv,
          \   'env': { 'PIPENV_VENV_IN_PROJECT': '1' },
          \   'out_io': 'null',
          \   'err_io': 'null',
          \   'stoponexit': ''
          \ })
    while job_status(s:job) ==# 'run'
      sleep 100m
    endwhile
    unlet s:cmd s:job
  endif

  let $PATH = g:pyenv . '/.venv/bin:' . $PATH
  let g:python3_host_prog = g:pyenv . '/.venv/bin/python3'
  let &pythonthreehome = g:pyenv . '/.venv'
endif

" ndenv {{{2
if has('vim_starting') && executable('npm') && g:isdev
  let g:ndenv = g:vimfiles . '/.ndenv'

  if !isdirectory(g:ndenv . '/node_modules')
    call job_start(['npm', 'install'], {
          \   'cwd': g:ndenv,
          \   'out_io': 'null',
          \   'err_io': 'null',
          \   'stoponexit': ''
          \ })
  endif

  let $PATH = g:ndenv . '/node_modules/.bin:' . $PATH
endif

" goenv {{{2
if has('vim_starting') && executable('go') && g:isdev
  let g:goenv = g:vimfiles . '/.goenv'

  let $GOPATH = g:goenv . ':' . $GOPATH
  let $PATH = g:goenv . '/bin:' . $PATH
endif

" cachedir {{{2
if has('win32') && exists('$AppData')
  let g:cachedir = $AppData . '/Local/Vim/Cache'
elseif exists('$XDG_CACHE_HOME')
  let g:cachedir = $XDG_CACHE_HOME . '/vim'
else
  let g:cachedir = g:vimfiles . '/.cache'
endif
if isdirectory(g:cachedir)
  call setfperm(g:cachedir, 'rwx------')
else
  call mkdir(g:cachedir, 'p', 0700)
endif

" tempdir {{{2
if has('win32') && exists('$AppData')
  let g:tempdir = $AppData . '/Local/Temp'
elseif exists('$TEMP')
  let g:tempdir = printf('%s/vim-%d', $TEMP, g:uid)
else
  let g:tempdir = printf('/tmp/vim-%d', g:uid)
endif
if isdirectory(g:tempdir)
  call setfperm(g:tempdir, 'rwx------')
else
  call mkdir(g:tempdir, 'p', 0700)
endif

" dein.vim {{{1
let s:deindir = g:vimfiles . '/dein'
let s:deinrepo = s:deindir . '/repos/github.com/Shougo/dein.vim'

if has('vim_starting')
  if !isdirectory(s:deinrepo)
    let s:job = job_start(['git', 'clone',
          \ 'https://github.com/Shougo/dein.vim', s:deinrepo], {
          \   'cwd': g:pyenv,
          \   'out_io': 'null',
          \   'err_io': 'null',
          \   'stoponexit': ''
          \ })
    while job_status(s:job) ==# 'run'
      sleep 100m
    endwhile
    unlet s:job
  endif
  let &runtimepath = s:deinrepo . ',' . &runtimepath
endif

if dein#load_state(s:deindir)
  let s:plugins = g:vimfiles . '/plugins.toml'
  let s:devplugins = g:vimfiles . '/devplugins.toml'
  call dein#begin(s:deindir, [$MYVIMRC, s:plugins, s:devplugins])
  call dein#load_toml(s:plugins)
  if g:isdev
    call dein#load_toml(s:devplugins)
    for s:dir in glob('~/src/*/cions', 1, 1)
      call dein#local(s:dir, { 'frozen': 1, 'merged': 0 }, ['vim-*', '*.vim'])
    endfor
  endif
  call dein#end()
  call dein#save_state()
endif

if dein#check_install()
  call dein#install()
endif

if has('nvim')
  call dein#remote_plugins()
endif

if has('vim_starting')
  call dein#call_hook('source')
  autocmd VimEnter * call dein#call_hook('post_source')
endif

syntax enable
filetype plugin indent on

" options {{{1
set hidden
set mouse=a
set ttimeout
set ttimeoutlen=100
set shelltemp
set splitbelow
set splitright

set showtabline=2
set laststatus=2
set statusline=%F\ %y[%{&fenc?&fenc:&enc}:%{&ff}]%m%r%w%=(%l,%c)
set shortmess+=cmrFI
set belloff=all
set noruler
set noshowcmd
set noshowmode
set notitle

set scrolloff=3
set sidescroll=1
set sidescrolloff=1
set backspace=indent,eol,start
set virtualedit=block
set complete=.,i,d,t
set completeopt=menu
set pumheight=0
set matchpairs& matchpairs+=<:>
set nojoinspaces
set nrformats=bin,hex
set smarttab
set shiftround
set autoindent
set smartindent

set history=200
set cedit=<C-Q>
set wildmenu
set wildmode=longest:full,full
set suffixes& suffixes-=.h

set wrap
set linebreak
set breakindent
set breakindentopt=min:35,sbr
set showbreak=>\ 
set list
set listchars=tab:>-,trail:-,extends:>,precedes:<
set display=truncate,uhex
set concealcursor=nc
set conceallevel=2
set lazyredraw
set hlsearch
set highlight& highlight+=@:SpecialKey

set path=.,,
set noincsearch
set ignorecase
set smartcase

let &backupdir = '.,' . g:tempdir
let &directory = g:cachedir
set writebackup
set nobackup
set viminfo=
set viminfofile=NONE

if has('gui_running')
  set background=light
  set guioptions=abefiMg
  set iminsert=0
  set imsearch=0
  if has('gui_gtk3')
    set guifont=Monospace\ 12
  elseif has('gui_win32')
    set guifont=MiG_Mono:h12:cSHIFTJIS:qDRAFT
  endif
  if has('directx')
    set renderoptions=type:directx
  endif
else
  set background=dark
endif
colorscheme solarized

language messages en_US.UTF-8
set helplang=en,ja

if &term ==# 'win32'
  set termencoding=cp932
else
  set termencoding=utf-8
endif
set encoding=utf-8
set fileencodings=ucs-bom,utf-8,euc-jisx0213,cp932
set fileformats=unix,dos

if executable('ag')
  set grepprg=ag\ --nocolor\ --nogroup\ --column\ --follow
  set grepformat=%f:%l:%c:%m
else
  set grepprg=internal
endif

" key bindings {{{1
noremap s <Nop>
noremap S <Nop>
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap Y y$
nnoremap x "_x
nnoremap j gj
nnoremap k gk
nnoremap 0 g0
nnoremap ^ g^
nnoremap gj j
nnoremap gk k
nnoremap g0 0
nnoremap g^ ^
xnoremap < <gv
xnoremap > >gv

nnoremap <silent> gh :<C-u>nohlsearch<CR>
nnoremap <silent> gn :<C-u>set number!<CR>
nnoremap <silent> gN :<C-u>set relativenumber!<CR>
nnoremap <silent> gw :<C-u>set wrap! wrap?<CR>
nnoremap <silent> <C-l> <C-l>:<C-u>call lightline#update()<CR>

nmap ys <Plug>(operator-surround-append)
nmap yss <Plug>(operator-surround-append)<Plug>(textobj-line-a)
nmap cs <Plug>(operator-surround-replace)
nmap ds <Plug>(operator-surround-delete)
xmap S <Plug>(operator-surround-append)
map _ <Plug>(operator-replace)
map sl <Plug>(operator-reverse-lines)
map sw <Plug>(operator-reverse-text)
map gc <Plug>(caw:prefix)
nmap gci <Plug>(caw:hatpos:comment)
nmap gcd <Plug>(textmanip-duplicate-up)<Plug>(caw:hatpos:comment)+
xmap gcd <Plug>(textmanip-duplicate-up)gv<Plug>(caw:hatpos:comment)'>+
map [e <Plug>(edgemotion-k)
map ]e <Plug>(edgemotion-j)
map * <Plug>(asterisk-*)
map # <Plug>(asterisk-#)
map g* <Plug>(asterisk-g*)
map g# <Plug>(asterisk-g#)
nmap <Space>d <Plug>(textmanip-duplicate-down)
xmap <Space>d <Plug>(textmanip-duplicate-down)<Esc>
nmap <Space>D <Plug>(textmanip-duplicate-up)
xmap <Space>D <Plug>(textmanip-duplicate-up)<Esc>
xmap <Space>h <Plug>(textmanip-duplicate-left)
xmap <Space>l <Plug>(textmanip-duplicate-right)
xmap H <Plug>(textmanip-move-left)
xmap J <Plug>(textmanip-move-down)
xmap K <Plug>(textmanip-move-up)
xmap L <Plug>(textmanip-move-right)

cnoremap <C-A> <Home>
cnoremap <C-B> <Left>
cnoremap <C-F> <Right>

tnoremap <C-W>gT <C-W>:tabprev<CR>
tnoremap <C-W>gt <C-W>:tabnext<CR>
tnoremap <silent> <C-W><C-h> <C-W>:call job_stop(term_getjob(bufnr('%')), 'hup')<CR>
tnoremap <C-W><Esc> <C-W>N

" commands {{{1
" Update {{{2
function! s:update() abort
  call dein#update()

  if executable('pipenv')
    call job_start(['pipenv', 'update'], {
          \   'cwd': g:pyenv,
          \   'env': { 'PIPENV_VENV_IN_PROJECT': '1' },
          \   'out_io': 'null',
          \   'err_io': 'null',
          \   'stoponexit': ''
          \ })
  endif

  if executable('npm') && g:isdev
    call job_start(['npm', 'install'], {
          \   'cwd': g:ndenv,
          \   'out_io': 'null',
          \   'err_io': 'null',
          \   'stoponexit': ''
          \ })
  endif

  if exists(':GoUpdateBinaries') == 2
    GoUpdateBinaries
  endif

  if executable('gocode')
    call job_start(['go', 'get', '-u', 'github.com/mdempsky/gocode'], {
          \   'cwd': g:goenv,
          \   'out_io': 'null',
          \   'err_io': 'null',
          \   'stoponexit': ''
          \ })
  endif
endfunction
command! Update call s:update()

" Clean {{{2
function! s:clean() abort
  for plugin in dein#check_clean()
    call delete(plugin, 'rf')
    call delete(fnamemodify(plugin, ':h'), 'd')
  endfor
  call dein#each('git gc')
  call dein#recache_runtimepath()
endfunction
command! Clean call s:clean()

" SynStack {{{2
function! s:synstack() abort
  let stack = synstack(line('.'), col('.'))
  let names = map(stack, { i, v -> synIDattr(v, 'name') })
  echomsg join(names, ' / ')
endfunction
command! SynStack call s:synstack()

" Highlight {{{2
function! s:highlight() abort
  let synid = synIDtrans(synID(line('.'), col('.'), 1))
  echomsg synIDattr(synid, 'name')
endfunction
command! Highlight call s:highlight()

" autocmd {{{1
function! s:auto_mkdir(dir, force) abort " {{{2
  if isdirectory(a:dir)
    return
  endif
  let prompt = '"%s" does not exists. Create? [y/N] '
  if a:force || input(prompt, a:dir) =~? '^y\%[es]$'
    call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
  endif
endfunction " }}}2

augroup vimrc
  autocmd!

  autocmd BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)

  autocmd BufWritePost,BufFilePost * nested filetype detect
  autocmd BufWritePost vimrc nested source $MYVIMRC | let &l:ft = &l:ft
  autocmd BufWritePost *.toml nested source $MYVIMRC | let &l:ft = &l:ft
augroup END
