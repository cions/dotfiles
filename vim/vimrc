" vim: set foldmethod=marker:

" prelude {{{1
let $VIMFILES = expand('<sfile>:p:h')
let g:uid = executable('id') ? str2nr(system('id -u')) : -1

" python {{{2
if has('vim_starting') && has('python3')
  let g:pyenv = expand('$VIMFILES/.pyenv')
  let g:python_modules = ['flake8', 'jedi', 'neovim']
  if !isdirectory(g:pyenv)
    call vimrc#pyenv#init()
  endif

  let $PATH = g:pyenv . '/bin:' . $PATH
  let g:python3_host_prog = g:pyenv . '/bin/python3'
  call vimrc#pyenv#init_path()
endif

" ndenv {{{2
if has('vim_starting') && executable('npm') && $UID != 0
  let g:ndenv = expand('$VIMFILES/.ndenv')
  let g:node_packages = ['eslint', 'tern', 'typescript', 'stylelint', 'prettier']
  " if !isdirectory(g:ndenv)
  "   call vimrc#ndenv#init()
  " endif

  let $PATH = g:ndenv . '/node_modules/.bin:' . $PATH
endif

" goenv {{{2
if has('vim_starting') && executable('go') && $UID != 0
  let g:goenv = expand('$VIMFILES/.goenv')
  let $GOPATH = g:goenv . ':' . $GOPATH
  let $PATH = g:goenv . '/bin:' . $PATH
endif

" cachedir {{{2
if has('win32') && exists('$AppData')
  let $CACHEDIR = expand('$AppData/Local/Vim/Cache')
elseif exists('$XDG_CACHE_HOME')
  let $CACHEDIR = expand('$XDG_CACHE_HOME/vim')
else
  let $CACHEDIR = expand('$VIMFILES/.cache')
endif
if isdirectory($CACHEDIR)
  call setfperm($CACHEDIR, 'rwx------')
else
  call mkdir($CACHEDIR, 'p', 0700)
endif

" tempdir {{{2
if has('win32') && exists('$AppData')
  let $TEMPDIR = expand('$AppData/Local/Temp')
elseif exists('$TEMP')
  let $TEMPDIR = expand('$TEMP/vim-$UID')
else
  let $TEMPDIR = expand('/tmp/vim-$UID')
endif
if isdirectory($TEMPDIR)
  call setfperm($TEMPDIR, 'rwx------')
else
  call mkdir($TEMPDIR, 'p', 0700)
endif

" dein.vim {{{1
let s:deindir = expand('$VIMFILES/dein')
let s:deinrepo = s:deindir . '/repos/github.com/Shougo/dein.vim'

if has('vim_starting')
  if !isdirectory(s:deinrepo)
    call system('git clone https://github.com/Shougo/dein.vim ' .
          \ shellescape(s:deinrepo))
  endif
  let &runtimepath = s:deinrepo . ',' . &runtimepath
endif

if dein#load_state(s:deindir)
  let s:plugins = expand('$VIMFILES/rc/plugins.toml')
  let s:ftplugins = expand('$VIMFILES/rc/ftplugins.toml')
  call dein#begin(s:deindir, [$MYVIMRC, s:plugins, s:ftplugins])
  call dein#load_toml(s:plugins)
  if $UID != 0
    call dein#load_toml(s:ftplugins)
    for s:dir in glob('~/src/*/cions', 1, 1)
      call dein#local(s:dir, { 'frozen': 1, 'merged': 0 }, ['vim-*', '*.vim'])
    endfor
  endif
  call dein#end()
  call dein#save_state()
endif

if dein#check_install()
  call dein#install()
endif

if has('nvim')
  call dein#remote_plugins()
endif

if has('vim_starting')
  call dein#call_hook('source')
  autocmd VimEnter * call dein#call_hook('post_source')
endif

syntax enable
filetype plugin indent on

" options {{{1
set hidden
set mouse=a
set ttimeout
set ttimeoutlen=100
set shelltemp
set splitbelow
set splitright

set showtabline=2
set laststatus=2
set statusline=%F\ %y[%{&fenc?&fenc:&enc}:%{&ff}]%m%r%w%=(%l,%c)
set shortmess+=cmrFI
set belloff=all
set noruler
set noshowcmd
set noshowmode
set notitle

set scrolloff=3
set sidescroll=1
set sidescrolloff=1
set backspace=indent,eol,start
set virtualedit=block
set complete=.,i,d,t
set completeopt=menu
set pumheight=0
set matchpairs& matchpairs+=<:>
set nojoinspaces
set nrformats=bin,hex
set smarttab
set shiftround
set autoindent
set smartindent

set history=200
set cedit=<C-Q>
set wildmenu
set wildmode=longest:full,full
set suffixes& suffixes-=.h

set wrap
set linebreak
set breakindent
set breakindentopt=min:35,sbr
set showbreak=>\ 
set list
set listchars=tab:>-,trail:-,extends:>,precedes:<
set display=truncate,uhex
set concealcursor=nc
set conceallevel=2
set lazyredraw
set hlsearch
set highlight& highlight+=@:SpecialKey

set path=.,,
set noincsearch
set ignorecase
set smartcase

set backupdir=.,$TEMPDIR
set directory=$CACHEDIR
set writebackup
set nobackup
set viminfo=
set viminfofile=NONE

if has('gui_running')
  set background=light
  set guioptions=abefiMg
  set iminsert=0
  set imsearch=0
  if has('gui_gtk3')
    set guifont=Monospace\ 12
  elseif has('gui_win32')
    set guifont=MiG_Mono:h12:cSHIFTJIS:qDRAFT
  endif
  if has('directx')
    set renderoptions=type:directx
  endif
else
  set background=dark
endif
colorscheme solarized

language messages en_US.UTF-8
set helplang=en,ja

if &term ==# 'win32'
  set termencoding=cp932
else
  set termencoding=utf-8
endif
set encoding=utf-8
set fileencodings=ucs-bom,utf-8,euc-jisx0213,cp932
set fileformats=unix,dos

if executable('ag')
  set grepprg=ag\ --nocolor\ --nogroup\ --column\ --follow
  set grepformat=%f:%l:%c:%m
elseif
  set grepprg=internal
endif

" key bindings {{{1
noremap s <Nop>
noremap S <Nop>
nnoremap ZZ <Nop>
nnoremap ZQ <Nop>
nnoremap Y y$
nnoremap x "_x
nnoremap j gj
nnoremap k gk
nnoremap 0 g0
nnoremap ^ g^
nnoremap gj j
nnoremap gk k
nnoremap g0 0
nnoremap g^ ^
xnoremap < <gv
xnoremap > >gv

nnoremap <silent> gh :<C-u>nohlsearch<CR>
nnoremap <silent> gn :<C-u>set number!<CR>
nnoremap <silent> gN :<C-u>set relativenumber!<CR>
nnoremap <silent> gw :<C-u>set wrap! wrap?<CR>
nnoremap <silent> <C-l> <C-l>:<C-u>call lightline#update()<CR>

nmap ys <Plug>(operator-surround-append)
nmap yss <Plug>(operator-surround-append)<Plug>(textobj-line-a)
nmap cs <Plug>(operator-surround-replace)
nmap ds <Plug>(operator-surround-delete)
xmap S <Plug>(operator-surround-append)
map _ <Plug>(operator-replace)
map sl <Plug>(operator-reverse-lines)
map sw <Plug>(operator-reverse-text)
map gc <Plug>(caw:prefix)
nmap gci <Plug>(caw:hatpos:comment)
nmap gcd <Plug>(textmanip-duplicate-up)<Plug>(caw:hatpos:comment)+
xmap gcd <Plug>(textmanip-duplicate-up)gv<Plug>(caw:hatpos:comment)'>+
map [e <Plug>(edgemotion-k)
map ]e <Plug>(edgemotion-j)
map * <Plug>(asterisk-*)
map # <Plug>(asterisk-#)
map g* <Plug>(asterisk-g*)
map g# <Plug>(asterisk-g#)
nmap <Space>d <Plug>(textmanip-duplicate-down)
xmap <Space>d <Plug>(textmanip-duplicate-down)<Esc>
nmap <Space>D <Plug>(textmanip-duplicate-up)
xmap <Space>D <Plug>(textmanip-duplicate-up)<Esc>
xmap <Space>h <Plug>(textmanip-duplicate-left)
xmap <Space>l <Plug>(textmanip-duplicate-right)
xmap H <Plug>(textmanip-move-left)
xmap J <Plug>(textmanip-move-down)
xmap K <Plug>(textmanip-move-up)
xmap L <Plug>(textmanip-move-right)

cnoremap <C-A> <Home>
cnoremap <C-B> <Left>
cnoremap <C-F> <Right>

tnoremap <C-W>gT <C-W>:tabprev<CR>
tnoremap <C-W>gt <C-W>:tabnext<CR>
tnoremap <silent> <C-W><C-h> <C-W>:call job_stop(term_getjob(bufnr('%')), 'hup')<CR>
tnoremap <C-W><Esc> <C-W>N

" commands {{{1
function! s:clean() abort
  for plugin in dein#check_clean()
    call delete(plugin, 'rf')
    call delete(fnamemodify(plugin, ':h'), 'd')
  endfor
  call dein#each('git gc')
  call dein#recache_runtimepath()
endfunction
command! Clean call s:clean()

function! s:synstack() abort
  let stack = synstack(line('.'), col('.'))
  let names = map(stack, { i, v -> synIDattr(v, 'name') })
  echomsg join(names, ' / ')
endfunction
command! SynStack call s:synstack()

function! s:highlight() abort
  let synid = synIDtrans(synID(line('.'), col('.'), 1))
  echomsg synIDattr(synid, 'name')
endfunction
command! Highlight call s:highlight()

" autocmd {{{1
function! s:auto_mkdir(dir, force) abort
  if isdirectory(a:dir)
    return
  endif
  let prompt = '"%s" does not exists. Create? [y/N] '
  if a:force || input(prompt, a:dir) =~? '^y\%[es]$'
    call mkdir(iconv(a:dir, &encoding, &termencoding), 'p')
  endif
endfunction

augroup vimrc
  autocmd!

  autocmd BufWritePre * call s:auto_mkdir(expand('<afile>:p:h'), v:cmdbang)

  autocmd BufWritePost,BufFilePost * nested filetype detect
  autocmd BufWritePost vimrc nested source $MYVIMRC | let &l:ft = &l:ft
  autocmd BufWritePost *.toml nested source $MYVIMRC | let &l:ft = &l:ft
augroup END
